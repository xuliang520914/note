### 分析查询慢的方法
- 记录慢查询日志
  - 分析日志，不要直接打开，可以通过`pt-query-digest`工具进行分析
- show profile
  - `set profiling=1;`开启，服务器上执行的所有会检测消耗时间，存到临时表
  - `show profiles`然后`show profiles for query 临时表id`
  - 字段：`query_id`，`duration`，`query`。id，执行时间，语句
  - 查询对应id查看执行时间在哪里话费比较多`status`,`duration`
- show status
  - 会返回计数器，show global status查看服务器级别的所有计数
  - 有时可以根据这些计数，可以猜测出那些操作代价较高或者消耗时间多
- show processlist
  - 观察是否有大量线程处于不正常的状态或特征
- explain/desc
  - 分析单条的SQL语句
  - `id`,`select_type`,`table`,`type`,`possible_key`,`key`,`key_len`,`ref`,`rows`,`extra`

### 优化查询过程中的数据访问
- 访问数据太多导致查询数据下降
- 是否检索大量超过需要的数据，可能太多行或太多列
- 确认MySQL服务器是否在分析大量不需要的数据行
- 避免使用如下SQL语句
  - 查询不需要的记录，比如只需要100条，使用limit解决
  - 多表关联返回全部列，指定需要的字段：a.id,b.name...
  - 总是取出全部列。select * 会让优化器无法完成索引覆盖扫描的优化
- 重复查询相同的数据，可以缓存数据
- 使用explain分析，查看是否需要扫描大量数据返回很少的行数
  - 可以使用索引覆盖扫描
  - 改变数据表结构，修改数据表的范式
- 重写SQL语句，可以让优化器用更优的方式执行查询

### 优化长难得查询语句
- MySQL每秒能扫描内存中很多数据，相比之下响应数据给客户端就慢
- 使用尽可能少的查询，但有时也需要将大的查询分解成小的查询
- 切分查询：将一次很多的记录分段查询
- 分解关联查询：将一条关联语句分解成多条语句执行
  - 缓存效率高
  - 执行单个查询可以减少锁竞争
  - 在应用层做关联，可以更容易对数据库进行拆分
- 优化count()查询
  - count(*)会忽略所有列，直接统计所有列数，因此不要使用count(字段)
  - 在MyISAM中没有任何where条件的count(*)非常快，因为MyISAM中记录了行数
- 优化关联查询
  - 确认on或者using子句上的列是否有索引
  - 确保group by和order by中只有一个列，这样MySQL才有可能使用索引
- 优化子查询
  - 尽可能使用关联查询替代
- 优化group by和distinct
  - 都可以使用索引优化
  - 在关联查询中使用标识列进行分组效率更高
  - 如果不需要使用order by，进行group by时使用order by null，MySQL不会在进行数据排序
  - with rollup超级聚合，可以挪到应用程序处理
- 优化limit分页
  - limit偏移量大的时候查询效率会低
  - 可以记录上次查询的最后id，下次直接根据该id查询
- 优化union
  - 使用union all效率高于union

