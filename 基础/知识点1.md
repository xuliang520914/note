- http协议
    - 基于应用层的面向对象的协议。在`TCP/IP`之上
    - 状态码
      - `1xx`表示请求已接收，继续处理
      - `2xx`表示处理成功
      - `3xx`表示重定向
      - `4xx`客户端错误-请求语法错误或者请求无法实现
      - `5xx`服务端错误-服务器未能实现合法的请求
        - `200` 请求成功，请求需要的响应头和数据体随着响应返回
        - `301` 请求资源被永久移动，重定向
        - `302` 请求资源临时由其他uri响应请求
        - `401` 需要验证用户权限
        - `403` 请求资源不可用
        - `404` 未找到请求资源
        - `405` 请求method不被允许
        - `500` 服务器遇到未曾预料到的错误
    - 特点
      - 简单快速
        - 客户端向服务端请求，只需要传送请求方法、路径
      - 灵活
        - 允许传递任意类型数据。`content-type`标记
      - 无连接
        - 每次连接只处理一个请求
      - 无状态
        - `HTTP`协议是无状态协议，就是对事务处理没有记忆功能
      - 支持`B/S`和`C/S`模式

- 面向对象六大基本原则
  - 单一职责原则：类的职责单一，一个类只做好一件事
  - 里氏替换原则：子类可以扩展父类，但是不能没有父类的原有功能。尽量不要重写父类的方法，也尽量不要重载父类的方法。
  - 依赖倒置原则：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象
  - 接口隔离原则：建立单一接口，尽量细化接口，接口中的方法尽量少。低耦合高内聚。
  - 最少知识原则：一个对象应该对其他对象保持最少的了解
  - 开闭原则：对扩展开放，修改关闭

- 设计模式
  - 单例模式：只实例化一次
  - 工厂模式：常用于根据传的配置不同，生成多个对应的实例
  - 观察者模式：该模式允许某个类观察另一个类的状态，当被观察的类状态发生改变的时候，观察类可以收到通知并且做出相应的动作;观察者模式为您提供了避免组件之间紧密耦。
  - 适配器模式：老代码接口不适应新的接口需求，或者代码很多很乱不便于继续修改，或者使用第三方类库。例如：php连接数据库的方法：`mysql`,`mysqli`,`pdo`,可以用适配器统一
  - 策略模式：将一组特定的行为和算法封装成类，以适应某些特定的上下文环境。例如：一个电商网站系统，针对男性女性用户要各自跳转到不同的商品类目，并且所有广告位展示不同的广告
  - 装饰器模式：动态地添加修改类的功能
  - 门面模式：一个接口统一调用多个系统的接口。屏蔽子系统组件，实现子系统与客户间的松耦合。
  - 注册模式：解决全局共享和交换对象
  - 原型模式：大对象的创建，对象克隆以避免创建对象时的消耗

- `require`和`include`
  - `require`读取文件失败会提示（Fatal error），程序停止执行；`include`则提示（Warning），不会停止执行
  - `include`执行文件时每次都要进行读取，`require`只处理一次（文本内容替换`require`语句）
  - `include一般放在流程控制的处理区段，`require`最前面
  - PHP读取到`include`时才会执行，而`require`在执行前就会读入文件
  - `include`可以放在条件判断中，`require`放在条件中无论条件是否成立都会被执行
